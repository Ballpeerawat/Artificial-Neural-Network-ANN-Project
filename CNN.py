# -*- coding: utf-8 -*-
"""OK CNN

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12CkhfMs0gs3Cjkqth4BQaHJI9LBKUPWv
"""

import os
import cv2
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from numpy import unique, argmax
from tensorflow.keras.datasets.mnist import load_data
from tensorflow.keras import Sequential
from tensorflow.keras.layers import Conv2D
from tensorflow.keras.layers import MaxPool2D, Dense, Flatten, Dropout
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras.utils import plot_model

"""# **Create Model**"""

earlys = EarlyStopping(monitor='val_loss', verbose=1, patience=20)

train_new_model = True
if train_new_model:
    mnist = tf.keras.datasets.mnist
    (x_train, y_train), (x_test, y_test) = mnist.load_data()

    nclass = len(np.unique(y_train))
# Fix Scale
    x_train = x_train.reshape(60000, 28, 28, 1)
    x_test = x_test.reshape(10000, 28, 28, 1)

    x_train = x_train.astype('float32') / 255
    x_test = x_test.astype('float32') / 255

# Convolutional
    model = Sequential()
    model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)))
    model.add(MaxPool2D((2, 2)))

    model.add(Conv2D(32, (3, 3), activation='relu'))
    model.add(MaxPool2D(2, 2))

    model.add(Flatten())
    model.add(Dropout(0.4))
    model.add(Dense(128, activation='relu'))
    model.add(Dropout(0.4))

    model.add(Dense(nclass, activation='softmax'))
    model.summary()

    plot_model(model, 'digit.png', show_shapes=True, show_layer_names=True)
    model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])
    import time
    start = time.time()
    history = model.fit(x_train, y_train, epochs=45, batch_size=128, verbose=0, validation_split=0.1, callbacks=[earlys])
    end = time.time()

    loss, accuracy = model.evaluate(x_test, y_test, verbose=0)
    print("Loss:", loss)
    print("Accuracy:", accuracy)

    model.save('handwritten_digits.model')
else:
    model = tf.keras.models.load_model('handwritten_digits.model')

plt.plot(history.history['loss'], color='b', label="Training")
plt.plot(history.history['val_loss'], 'r--', label="Validation")
plt.title("Loss")
plt.legend()
plt.show()

def visual_multi(i):
    nplots = 50
    fig = plt.figure(figsize= (8,5))
    for j in  range(nplots):
        plt.subplot(5,10, j+1)
        plt.imshow(x_train[i+j], cmap= plt.cm.gray_r)
        plt.title(y_train[i+j])
        plt.xticks([])
    plt.show()
visual_multi(0)

y_pred = model.predict(x_test)
y_pred_cls = np.argmax(y_pred, axis=1)
idx_miss = np.where(y_pred_cls != y_test)
print(len(idx_miss[0]))

"""# **Predicted Model**"""

from PIL import Image
import os

# Set target size for resizing
target_size = (28, 28)

# Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Directory containing images
image_dir = '/content/digit'

# List to store resized images
images = []
loaded_images = 0

for filename in os.listdir(image_dir):
    if loaded_images >= 50:
        break

    # Check if the file is a JPG image
    if filename.endswith('jpg'):
        try:
            with Image.open(os.path.join(image_dir, filename)) as img:
                img = img.convert('L')
                img = img.resize(target_size)
                images.append(img)
                loaded_images += 1
        except Exception:
            continue

print(f'Loaded images: {len(images)}')

actual_value = [3,7,9,6,5,2,6,5,3,7,
                2,3,9,4,1,3,0,2,3,2,
                4,6,7,1,7,9,1,1,4,7,
                5,2,8,8,8,8,7,9,6,4,
                7,2,8,4,2,1,2,2,1,6]

def image_path(i):
    nplot = 50
    fig = plt.figure(figsize =(14, 8))
    for j in range(nplot):
        plt.subplot(5, 10, j+1)
        plt.imshow(images[i+j], cmap='gray_r')
        plt.title(actual_value[i+j])
        plt.xticks([])
    plt.show()

image_path(0)

# images เป็นอาร์เรย์ของ NumPy
images_1 = np.array([np.array(img) for img in images])

# Reshape เพื่อให้เหมาะสมกับการนำเข้าข้อมูลให้กับโมเดล
images_2 = images_1.reshape(-1, 28, 28, 1)

# ทำหน้าที่ทำให้สีของรูปภาพกลับดำเป็นขาวและขาวเป็นดำ
images_2 = 255 - images_2

predictions = model.predict(images_2)

#  Check correct and incorrect predictions using if-else
correct_pred = 0
incorrect_pred = 0

predicted_class = list(np.argmax(predictions, axis=1))

for pred, actual in zip(predicted_class, actual_value):
    if pred == actual:
        correct_pred += 1
    else:
        incorrect_pred += 1

total_images = len(actual_value)

print(f"Total Images : {total_images}")
print(f"Correctly Predicted Images : {correct_pred}")
print(f"Incorrectly Predicted Images : {incorrect_pred}")

print(actual_value)
print("------")
print("------")
print("------")
print(predicted_class)

#images_3 = images_2.tolist()
fig=plt.figure(figsize=(20,10))
for i in range(len(images)):
    plt.subplot(5,10,i+1)
    plt.imshow(images_2[i], cmap='gray_r')
    plt.title(f'Predicted Digit: {predicted_class[i]}')
    plt.xticks([])
    plt.yticks([])
    plt.axis('off')
plt.show()

print("**")
print("All images processed.")
print("**")

